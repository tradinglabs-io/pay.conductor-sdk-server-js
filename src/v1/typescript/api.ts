/* tslint:disable */
/* eslint-disable */
/**
 * PayConductor API
 * # Introdução  Esta documentação cobre todas as funcionalidades disponíveis na API RESTful do PayConductor, incluindo autenticação, gerenciamento de recursos e exemplos de uso.  <br />  <br />  ----  <br />   # Autenticação  A API do PayConductor utiliza autenticação HTTP Basic para validar requisições. Você precisa fornecer suas credenciais (Client ID e Client Secret) no formato `client:secret` codificado em Base64.  <br />  ## Obtendo Credenciais  1. Acesse o painel administrativo do PayConductor 2. Navegue até **Configurações > API Keys** 3. Gere um novo par de credenciais (Client ID e Client Secret) 4. Guarde o Client Secret em local seguro - ele não será exibido novamente  <br />  ## Formato de Autenticação  As credenciais devem ser enviadas no header `Authorization` usando o esquema Basic:  ``` Authorization: Basic base64(client_id:client_secret) ```  <br />  ## Exemplo em Node.js  ```javascript const clientId = \'seu_client_id\'; const clientSecret = \'seu_client_secret\';  // Codifica as credenciais em Base64 const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString(\'base64\');  const response = await fetch(\'https://api.payconductor.com/api/v1/orders\', {   method: \'GET\',   headers: {     \'Authorization\': `Basic ${credentials}`,     \'Content-Type\': \'application/json\'   } });  const data = await response.json(); console.log(data); ```  <br />  ## Erros de Autenticação  | Código | Descrição | |--------|-----------| | `401`  | Credenciais inválidas ou ausentes | | `403`  | Credenciais válidas, mas sem permissão para o recurso | | `429`  | Muitas requisições (rate limit excedido) |  ### Exemplo de resposta de erro  ```json {   \"error\": {     \"code\": \"UNAUTHORIZED\",     \"message\": \"Invalid credentials\",     \"details\": \"The provided client ID or secret is incorrect\"   } } ```
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Boleto {
    'paymentMethod': string;
    'expirationInDays'?: BoletoExpirationInDays;
}
/**
 * Dias até o vencimento do boleto
 */
export interface BoletoExpirationInDays {
}
export interface CartODeCrDito {
    'paymentMethod': string;
    'card': CartODeCrDitoCard;
    'installments': CartODeCrDitoInstallments;
    /**
     * Texto que aparecerá na fatura do cartão (soft descriptor)
     */
    'softDescriptor'?: string;
}
export interface CartODeCrDitoCard {
    /**
     * Primeiros 6 dígitos do cartão de crédito
     */
    'firstSixCardNumber'?: string;
    /**
     * Token do cartão de crédito gerado anteriormente
     */
    'token': string;
    /**
     * Código de segurança do cartão (CVV)
     */
    'cvv': string;
    'expiration': DadosCompletosDoCartOExpiration;
    /**
     * Nome do titular do cartão
     */
    'holderName': string;
    /**
     * Número do cartão de crédito
     */
    'number': string;
}
/**
 * Número de parcelas
 */
export interface CartODeCrDitoInstallments {
}
export interface CartOTokenizado {
    /**
     * Primeiros 6 dígitos do cartão de crédito
     */
    'firstSixCardNumber'?: string;
    /**
     * Token do cartão de crédito gerado anteriormente
     */
    'token': string;
}
/**
 * Schema para criação de um novo cliente
 */
export interface Cliente {
    'address'?: EndereODoCliente;
    /**
     * CPF ou CNPJ do cliente sem formatação
     */
    'documentNumber': string;
    'documentType': ClienteDocumentTypeEnum;
    /**
     * Email do cliente
     */
    'email': string;
    /**
     * Nome completo do cliente
     */
    'name': string;
    /**
     * Número de telefone do cliente no formato +55 DD 9XXXXXXXX
     */
    'phoneNumber'?: string;
}

export const ClienteDocumentTypeEnum = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj'
} as const;

export type ClienteDocumentTypeEnum = typeof ClienteDocumentTypeEnum[keyof typeof ClienteDocumentTypeEnum];

export interface DadosCompletosDoCartO {
    /**
     * Código de segurança do cartão (CVV)
     */
    'cvv': string;
    'expiration': DadosCompletosDoCartOExpiration;
    /**
     * Nome do titular do cartão
     */
    'holderName': string;
    /**
     * Número do cartão de crédito
     */
    'number': string;
}
export interface DadosCompletosDoCartOExpiration {
    /**
     * Mês de expiração do cartão
     */
    'month': number;
    /**
     * Ano de expiração do cartão
     */
    'year': number;
}
/**
 * Schema para criação de um novo endereço
 */
export interface EndereODoCliente {
    /**
     * Nome da cidade
     */
    'city': string;
    /**
     * Código do país no formato ISO 3166-1 alpha-2
     */
    'country': string;
    /**
     * Nome do bairro
     */
    'neighborhood': string;
    /**
     * Número do endereço
     */
    'number': string;
    /**
     * Código do estado no formato ISO 3166-2
     */
    'state': string;
    /**
     * Nome da rua
     */
    'street': string;
    /**
     * CEP sem formatação
     */
    'zipCode': string;
}
/**
 * Dados do merchant para pedido ou saque
 */
export interface MerchantInput {
    /**
     * CPF ou CNPJ do merchant sem formatação
     */
    'document': string;
    /**
     * Email do merchant
     */
    'email': string;
    /**
     * Nome do merchant
     */
    'name': string;
}
export interface NuPay {
    'paymentMethod': string;
    'nuPay': NuPayNuPay;
}
/**
 * Dados específicos para pagamento via NuPay
 */
export interface NuPayNuPay {
    /**
     * URL de cancelamento do pagamento
     */
    'cancelUrl': string;
    /**
     * Nome do comerciante
     */
    'merchantName': string;
    /**
     * URL de retorno após a conclusão do pagamento
     */
    'returnUrl': string;
    /**
     * Nome da loja
     */
    'storeName'?: string;
}
export interface PicPay {
    'paymentMethod': string;
}
export interface Pix {
    'paymentMethod': string;
    'expirationInSeconds'?: PixExpirationInSeconds;
}
/**
 * Tempo de expiração do PIX em segundos
 */
export interface PixExpirationInSeconds {
}
export interface PostOrders200Response {
    /**
     * ID do pedido no sistema
     */
    'id': string;
    /**
     * ID externo do pedido (fornecido pela sua integração)
     */
    'externalId': string | null;
    /**
     * Provedor utilizada para processar o pedido
     */
    'externalIntegrationKey': string;
    /**
     * ID do pedido no provedor de pagamento
     */
    'externalIntegrationId': string | null;
    /**
     * Valor total do pedido
     */
    'amount': number;
    /**
     * Taxa de custo aplicada ao pedido
     */
    'costFee': number;
    'pix'?: PostOrders200ResponsePix;
    'bankSlip'?: PostOrders200ResponseBankSlip;
    'nuPay'?: PostOrders200ResponseNuPay;
    'picPay'?: PostOrders200ResponsePicPay;
    'creditCard'?: PostOrders200ResponseCreditCard;
    'status': PostOrders200ResponseStatusEnum;
    'paymentMethod': PostOrders200ResponsePaymentMethodEnum;
    /**
     * Data e hora em que o pedido foi pago (ISO 8601)
     */
    'payedAt': string | null;
    /**
     * Código de erro, se houver
     */
    'errorCode': string | null;
    /**
     * Mensagem de erro, se houver
     */
    'errorMessage': string | null;
    'orderItems': Array<PostOrders200ResponseOrderItemsInner>;
    'session'?: PostOrders200ResponseSession | null;
}

export const PostOrders200ResponseStatusEnum = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback'
} as const;

export type PostOrders200ResponseStatusEnum = typeof PostOrders200ResponseStatusEnum[keyof typeof PostOrders200ResponseStatusEnum];
export const PostOrders200ResponsePaymentMethodEnum = {
    Pix: 'Pix',
    CreditCard: 'CreditCard',
    DebitCard: 'DebitCard',
    BankSlip: 'BankSlip',
    Crypto: 'Crypto',
    ApplePay: 'ApplePay',
    NuPay: 'NuPay',
    PicPay: 'PicPay',
    AmazonPay: 'AmazonPay',
    SepaDebit: 'SepaDebit',
    GooglePay: 'GooglePay'
} as const;

export type PostOrders200ResponsePaymentMethodEnum = typeof PostOrders200ResponsePaymentMethodEnum[keyof typeof PostOrders200ResponsePaymentMethodEnum];

export interface PostOrders200ResponseBankSlip {
    /**
     * Código de barras do boleto
     */
    'barCode': string;
    /**
     * Linha digitável do boleto
     */
    'digitableLine': string;
    /**
     * URL do PDF do boleto
     */
    'pdfUrl'?: string;
}
export interface PostOrders200ResponseCreditCard {
    /**
     * Código de autorização da transação
     */
    'authorizationCode'?: string;
}
export interface PostOrders200ResponseNuPay {
    /**
     * URL de pagamento NuPay
     */
    'paymentUrl': string;
}
export interface PostOrders200ResponseOrderItemsInner {
    /**
     * ID externo do item
     */
    'externalId': string | null;
    /**
     * ID do item no pedido
     */
    'id': string;
    /**
     * Nome do produto/serviço
     */
    'name': string;
    /**
     * Quantidade
     */
    'qty': number;
    /**
     * Valor total do item (quantidade × preço unitário)
     */
    'totalAmount': number;
    /**
     * Valor líquido total do item
     */
    'totalNetAmount': number;
    /**
     * Preço unitário
     */
    'unityPrice': number;
}
export interface PostOrders200ResponsePicPay {
    /**
     * Código copia e cola do PicPay
     */
    'copyAndPasteCode': string;
    /**
     * URL da imagem do QR Code PicPay
     */
    'qrCodeUrl': string;
}
/**
 * Dados do PIX
 */
export interface PostOrders200ResponsePix {
    /**
     * Código copia e cola do PIX
     */
    'copyAndPasteCode': string;
    /**
     * URL da imagem do QR Code PIX
     */
    'qrCodeUrl': string;
    /**
     * E2E ID do PIX
     */
    'endToEndId': string | null;
}
export interface PostOrders200ResponseSession {
    /**
     * ID da sessão de checkout associada ao pedido
     */
    'sessionId': string;
}
export interface PostOrdersRequest {
    /**
     * Valor total a ser cobrado no pedido em valor flutuante
     */
    'chargeAmount': number;
    /**
     * Endereço IP do cliente
     */
    'clientIp': string;
    'customer': Cliente;
    /**
     * Valor do desconto
     */
    'discountAmount': number;
    /**
     * ID da ordem no seu sistema
     */
    'externalId': string;
    'fingerprints'?: PostOrdersRequestFingerprints;
    /**
     * Lista de produtos ou serviços do pedido
     */
    'items'?: Array<PostOrdersRequestItemsInner>;
    'merchant'?: MerchantInput;
    'payment': PostOrdersRequestPayment;
    /**
     * Valor total do split a ser pago ao merchant (Sendo usado apenas para fins de relatório, ou seja não gera split real)
     */
    'splitAmountTotal'?: number;
    'session'?: PostOrdersRequestSession;
    /**
     * Valor do frete
     */
    'shippingFee': number;
    /**
     * Taxas adicionais
     */
    'taxFee': number;
    /**
     * Metadados adicionais para o pedido como pares chave-valor. Não deve ter espaços ou caracteres especiais nas chaves
     */
    'metadata'?: object;
}
export interface PostOrdersRequestFingerprints {
    /**
     * ID de fingerprint do ThreatMetrix para análise de fraude
     */
    'threatMetrixFingerprintId'?: string;
}
export interface PostOrdersRequestItemsInner {
    /**
     * ID do produto ou serviço no seu sistema
     */
    'id': string;
    /**
     * Define se o item é um produto físico ou um serviço
     */
    'isPhysical': boolean;
    /**
     * Nome do produto ou serviço
     */
    'name': string;
    /**
     * Quantidade do produto ou serviço
     */
    'qty': number;
    /**
     * Preço unitário
     */
    'unitPrice': number;
}
/**
 * Dados de pagamento para o pedido (Pix, Cartão de Crédito, Boleto, NuPay, etc...)
 */
export interface PostOrdersRequestPayment {
    'paymentMethod': string;
    'expirationInSeconds'?: PixExpirationInSeconds;
    'card': CartODeCrDitoCard;
    'installments': CartODeCrDitoInstallments;
    /**
     * Texto que aparecerá na fatura do cartão (soft descriptor)
     */
    'softDescriptor'?: string;
    'expirationInDays'?: BoletoExpirationInDays;
    'nuPay': NuPayNuPay;
}
/**
 * Caso o externalSessionId ou sessionId sejam fornecidos e houver uma sessão existente, ela será atualizada com os novos dados. Caso contrário, uma nova sessão será criada.
 */
export interface PostOrdersRequestSession {
    /**
     * Tempo em minutos para expiração da sessão do checkout
     */
    'expiresInMinutes'?: number;
    /**
     * URL do checkout para que possamos redirecionar
     */
    'checkoutUrl'?: string;
    /**
     * Id gerado pelo nosso serviço para identificar a sessão de checkout
     */
    'sessionId'?: string;
    /**
     * Id da sessão de checkout gerado pelo lado do cliente. O id deve ser único para cada sessão de carrinho
     */
    'externalSessionId'?: string;
}
export interface PostWithdraws200Response {
    /**
     * Identificador único do saque
     */
    'id': string;
    /**
     * ID do saque no sistema no seu sistema
     */
    'externalId': string | null;
    /**
     * Chave do provedor utilizado para o saque
     */
    'externalIntegrationKey': string;
    /**
     * ID do saque no provedor de pagamento
     */
    'externalIntegrationId': string | null;
    /**
     * Taxa de custo aplicada ao saque
     */
    'costFee': number;
    /**
     * Status do saque
     */
    'status': PostWithdraws200ResponseStatusEnum;
    /**
     * Código do erro, se houver
     */
    'errorCode': string | null;
    /**
     * Mensagem descritiva do erro, se houver
     */
    'errorMessage': string | null;
    'payedAt': PostWithdraws200ResponsePayedAt | null;
    'payoutAccount': PostWithdraws200ResponsePayoutAccount;
}

export const PostWithdraws200ResponseStatusEnum = {
    Pending: 'Pending',
    Transferring: 'Transferring',
    Completed: 'Completed',
    Failed: 'Failed'
} as const;

export type PostWithdraws200ResponseStatusEnum = typeof PostWithdraws200ResponseStatusEnum[keyof typeof PostWithdraws200ResponseStatusEnum];

/**
 * Data e hora em que o saque foi pago (formato ISO 8601)
 */
export interface PostWithdraws200ResponsePayedAt {
}
export interface PostWithdraws200ResponsePayoutAccount {
    /**
     * Identificador único da conta de pagamento
     */
    'id': string;
    /**
     * Documento do titular da conta (CPF ou CNPJ)
     */
    'ownerDocument': string;
    /**
     * Nome do titular da conta
     */
    'ownerName': string;
    /**
     * Chave PIX utilizada para o saque
     */
    'pixKey': string;
    /**
     * Tipo da chave PIX
     */
    'pixType': PostWithdraws200ResponsePayoutAccountPixTypeEnum;
}

export const PostWithdraws200ResponsePayoutAccountPixTypeEnum = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj',
    Email: 'Email',
    Phone: 'Phone',
    Random: 'Random'
} as const;

export type PostWithdraws200ResponsePayoutAccountPixTypeEnum = typeof PostWithdraws200ResponsePayoutAccountPixTypeEnum[keyof typeof PostWithdraws200ResponsePayoutAccountPixTypeEnum];

export interface PostWithdrawsRequest {
    /**
     * Valor do saque em centavos
     */
    'amount': number;
    /**
     * ID do saque no seu sistema
     */
    'externalId'?: string;
    'merchant'?: MerchantInput;
    'payoutAccount': PostWithdrawsRequestPayoutAccount;
}
export interface PostWithdrawsRequestPayoutAccount {
    /**
     * Documento do titular da conta (CPF ou CNPJ)
     */
    'ownerDocument': string;
    /**
     * Nome do titular da conta
     */
    'ownerName': string;
    /**
     * PIX key for withdrawal
     */
    'pixKey': string;
    /**
     * PIX key type
     */
    'pixType': PostWithdrawsRequestPayoutAccountPixTypeEnum;
}

export const PostWithdrawsRequestPayoutAccountPixTypeEnum = {
    Cnpj: 'Cnpj',
    Cpf: 'Cpf',
    Email: 'Email',
    Phone: 'Phone',
    Random: 'Random'
} as const;

export type PostWithdrawsRequestPayoutAccountPixTypeEnum = typeof PostWithdrawsRequestPayoutAccountPixTypeEnum[keyof typeof PostWithdrawsRequestPayoutAccountPixTypeEnum];


/**
 * PedidosApi - axios parameter creator
 */
export const PedidosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Recupere uma lista de pedidos. Utilize os parâmetros de filtro de data e paginação para refinar os resultados conforme necessário.
         * @summary Listar pedidos
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getOrders', 'period', period)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getOrders', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getOrders', 'pageSize', pageSize)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Localize os dados completos de um pedido buscando pelo nosso id
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrdersById', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crie um novo pedido para pagamento utilizando os dados fornecidos
         * @summary Criar pedido
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders: async (postOrdersRequest: PostOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postOrdersRequest' is not null or undefined
            assertParamExists('postOrders', 'postOrdersRequest', postOrdersRequest)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inicie um reembolso para o pedido especificado pelo ID.
         * @summary Reembolsar pedido
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersByIdRefund: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersByIdRefund', 'id', id)
            const localVarPath = `/orders/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PedidosApi - functional programming interface
 */
export const PedidosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PedidosApiAxiosParamCreator(configuration)
    return {
        /**
         * Recupere uma lista de pedidos. Utilize os parâmetros de filtro de data e paginação para refinar os resultados conforme necessário.
         * @summary Listar pedidos
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(period, page, pageSize, endDate, startDate, id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PedidosApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Localize os dados completos de um pedido buscando pelo nosso id
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PedidosApi.getOrdersById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crie um novo pedido para pagamento utilizando os dados fornecidos
         * @summary Criar pedido
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrders(postOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PedidosApi.postOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inicie um reembolso para o pedido especificado pelo ID.
         * @summary Reembolsar pedido
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersByIdRefund(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PedidosApi.postOrdersByIdRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PedidosApi - factory interface
 */
export const PedidosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PedidosApiFp(configuration)
    return {
        /**
         * Recupere uma lista de pedidos. Utilize os parâmetros de filtro de data e paginação para refinar os resultados conforme necessário.
         * @summary Listar pedidos
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOrders(period, page, pageSize, endDate, startDate, id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Localize os dados completos de um pedido buscando pelo nosso id
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOrdersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Crie um novo pedido para pagamento utilizando os dados fornecidos
         * @summary Criar pedido
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostOrders200Response> {
            return localVarFp.postOrders(postOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Inicie um reembolso para o pedido especificado pelo ID.
         * @summary Reembolsar pedido
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postOrdersByIdRefund(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PedidosApi - object-oriented interface
 */
export class PedidosApi extends BaseAPI {
    /**
     * Recupere uma lista de pedidos. Utilize os parâmetros de filtro de data e paginação para refinar os resultados conforme necessário.
     * @summary Listar pedidos
     * @param {GetOrdersPeriodEnum} period 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {GetOrdersStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig) {
        return PedidosApiFp(this.configuration).getOrders(period, page, pageSize, endDate, startDate, id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Localize os dados completos de um pedido buscando pelo nosso id
     * @summary Buscar pelo ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrdersById(id: string, options?: RawAxiosRequestConfig) {
        return PedidosApiFp(this.configuration).getOrdersById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crie um novo pedido para pagamento utilizando os dados fornecidos
     * @summary Criar pedido
     * @param {PostOrdersRequest} postOrdersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig) {
        return PedidosApiFp(this.configuration).postOrders(postOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inicie um reembolso para o pedido especificado pelo ID.
     * @summary Reembolsar pedido
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig) {
        return PedidosApiFp(this.configuration).postOrdersByIdRefund(id, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetOrdersPeriodEnum = {
    Today: 'Today',
    Yesterday: 'Yesterday',
    Last7Days: 'Last7Days',
    Last30Days: 'Last30Days',
    ThisMonth: 'ThisMonth',
    LastMonth: 'LastMonth',
    ThisYear: 'ThisYear',
    Custom: 'Custom'
} as const;
export type GetOrdersPeriodEnum = typeof GetOrdersPeriodEnum[keyof typeof GetOrdersPeriodEnum];
export const GetOrdersStatusEnum = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback'
} as const;
export type GetOrdersStatusEnum = typeof GetOrdersStatusEnum[keyof typeof GetOrdersStatusEnum];


/**
 * SaquesETransfernciasApi - axios parameter creator
 */
export const SaquesETransfernciasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retorna uma lista paginada de saques e transferências. Permite filtrar por data de criação ou buscar por ID (ID do saque, ID externo, ID da adquirente ou End2EndID)
         * @summary Lista os saques
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdraws: async (period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getWithdraws', 'period', period)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getWithdraws', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getWithdraws', 'pageSize', pageSize)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna os detalhes de um saque ou transferência específico usando seu ID
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawsById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWithdrawsById', 'id', id)
            const localVarPath = `/withdraws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realiza um novo saque ou transferência para a conta de pagamento informada
         * @summary Cria saque
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraws: async (postWithdrawsRequest: PostWithdrawsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postWithdrawsRequest' is not null or undefined
            assertParamExists('postWithdraws', 'postWithdrawsRequest', postWithdrawsRequest)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postWithdrawsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SaquesETransfernciasApi - functional programming interface
 */
export const SaquesETransfernciasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SaquesETransfernciasApiAxiosParamCreator(configuration)
    return {
        /**
         * Retorna uma lista paginada de saques e transferências. Permite filtrar por data de criação ou buscar por ID (ID do saque, ID externo, ID da adquirente ou End2EndID)
         * @summary Lista os saques
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdraws(period, page, pageSize, endDate, startDate, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SaquesETransfernciasApi.getWithdraws']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna os detalhes de um saque ou transferência específico usando seu ID
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawsById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawsById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SaquesETransfernciasApi.getWithdrawsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realiza um novo saque ou transferência para a conta de pagamento informada
         * @summary Cria saque
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWithdraws200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWithdraws(postWithdrawsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SaquesETransfernciasApi.postWithdraws']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SaquesETransfernciasApi - factory interface
 */
export const SaquesETransfernciasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SaquesETransfernciasApiFp(configuration)
    return {
        /**
         * Retorna uma lista paginada de saques e transferências. Permite filtrar por data de criação ou buscar por ID (ID do saque, ID externo, ID da adquirente ou End2EndID)
         * @summary Lista os saques
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getWithdraws(period, page, pageSize, endDate, startDate, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna os detalhes de um saque ou transferência específico usando seu ID
         * @summary Buscar pelo ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawsById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getWithdrawsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Realiza um novo saque ou transferência para a conta de pagamento informada
         * @summary Cria saque
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostWithdraws200Response> {
            return localVarFp.postWithdraws(postWithdrawsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SaquesETransfernciasApi - object-oriented interface
 */
export class SaquesETransfernciasApi extends BaseAPI {
    /**
     * Retorna uma lista paginada de saques e transferências. Permite filtrar por data de criação ou buscar por ID (ID do saque, ID externo, ID da adquirente ou End2EndID)
     * @summary Lista os saques
     * @param {GetWithdrawsPeriodEnum} period 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig) {
        return SaquesETransfernciasApiFp(this.configuration).getWithdraws(period, page, pageSize, endDate, startDate, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna os detalhes de um saque ou transferência específico usando seu ID
     * @summary Buscar pelo ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdrawsById(id: string, options?: RawAxiosRequestConfig) {
        return SaquesETransfernciasApiFp(this.configuration).getWithdrawsById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realiza um novo saque ou transferência para a conta de pagamento informada
     * @summary Cria saque
     * @param {PostWithdrawsRequest} postWithdrawsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig) {
        return SaquesETransfernciasApiFp(this.configuration).postWithdraws(postWithdrawsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetWithdrawsPeriodEnum = {
    Today: 'Today',
    Yesterday: 'Yesterday',
    Last7Days: 'Last7Days',
    Last30Days: 'Last30Days',
    ThisMonth: 'ThisMonth',
    LastMonth: 'LastMonth',
    ThisYear: 'ThisYear',
    Custom: 'Custom'
} as const;
export type GetWithdrawsPeriodEnum = typeof GetWithdrawsPeriodEnum[keyof typeof GetWithdrawsPeriodEnum];


