/* tslint:disable */
/* eslint-disable */
/**
 * PayConductor API
 * PayConductor API Documentation.  This documentation covers all available features in the PayConductor RESTful API, including authentication, resource management, and usage examples.  <br />  <br />  ----  <br />   # Authentication  PayConductor API uses HTTP Basic authentication to validate requests. You need to provide your credentials (Client ID and Client Secret) in the `client:secret` format encoded in Base64.  <br />  ## Getting Credentials  1. Access the PayConductor admin panel 2. Navigate to **Settings > API Keys** 3. Generate a new credentials pair (Client ID and Client Secret) 4. Store the Client Secret in a secure location - it will not be displayed again  <br />  ## Authentication Format  Credentials must be sent in the `Authorization` header using the Basic scheme:  ``` Authorization: Basic base64(client_id:client_secret) ```  <br />  ## Node.js Example  ```javascript const clientId = \'your_client_id\'; const clientSecret = \'your_client_secret\';  // Encode credentials in Base64 const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString(\'base64\');  const response = await fetch(\'https://api.payconductor.com/api/v1/orders\', {   method: \'GET\',   headers: {     \'Authorization\': `Basic ${credentials}`,     \'Content-Type\': \'application/json\'   } });  const data = await response.json(); console.log(data); ```  <br />  ## Authentication Errors  | Code | Description | |------|-------------| | `401` | Invalid or missing credentials | | `403` | Valid credentials but no permission for the resource | | `429` | Too many requests (rate limit exceeded) |  ### Error Response Example  ```json {   \"error\": {     \"code\": \"UNAUTHORIZED\",     \"message\": \"Invalid credentials\",     \"details\": \"The provided client ID or secret is incorrect\"   } } ```
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BankSlip {
    'paymentMethod': string;
    'expirationInDays'?: BankSlipExpirationInDays;
}
/**
 * Days until bank slip expires
 */
export interface BankSlipExpirationInDays {
}
export interface CompleteCardData {
    /**
     * Card security code (CVV)
     */
    'cvv': string;
    'expiration': CompleteCardDataExpiration;
    /**
     * Card holder name
     */
    'holderName': string;
    /**
     * Credit card number
     */
    'number': string;
}
export interface CompleteCardDataExpiration {
    /**
     * Card expiration month
     */
    'month': number;
    /**
     * Card expiration year
     */
    'year': number;
}
export interface CreditCard {
    'paymentMethod': string;
    'card': CreditCardCard;
    'installments': CreditCardInstallments;
    /**
     * Text that will appear on the card statement (soft descriptor)
     */
    'softDescriptor'?: string;
}
export interface CreditCardCard {
    /**
     * First 6 digits of the credit card
     */
    'firstSixCardNumber'?: string;
    /**
     * Previously generated credit card token
     */
    'token': string;
    /**
     * Card security code (CVV)
     */
    'cvv': string;
    'expiration': CompleteCardDataExpiration;
    /**
     * Card holder name
     */
    'holderName': string;
    /**
     * Credit card number
     */
    'number': string;
}
/**
 * Number of installments
 */
export interface CreditCardInstallments {
}
/**
 * Schema for creating a new customer
 */
export interface Customer {
    'address'?: CustomerAddress;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber': string;
    'documentType': CustomerDocumentTypeEnum;
    /**
     * Customer email
     */
    'email': string;
    /**
     * Customer full name
     */
    'name': string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
}

export const CustomerDocumentTypeEnum = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj'
} as const;

export type CustomerDocumentTypeEnum = typeof CustomerDocumentTypeEnum[keyof typeof CustomerDocumentTypeEnum];

/**
 * Schema for creating a new customer
 */
export interface Customer1 {
    'address'?: CustomerAddress;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber'?: string;
    'documentType'?: Customer1DocumentTypeEnum;
    /**
     * Customer email
     */
    'email'?: string;
    /**
     * Customer full name
     */
    'name'?: string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
}

export const Customer1DocumentTypeEnum = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj'
} as const;

export type Customer1DocumentTypeEnum = typeof Customer1DocumentTypeEnum[keyof typeof Customer1DocumentTypeEnum];

/**
 * Schema for creating a new customer
 */
export interface Customer2 {
    'address'?: CustomerAddress;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber': string;
    'documentType': Customer2DocumentType;
    /**
     * Customer email
     */
    'email': string;
    /**
     * Customer full name
     */
    'name': string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
}
/**
 * Document type: Cpf or Cnpj
 */
export interface Customer2DocumentType {
}
/**
 * Schema for creating a new address
 */
export interface CustomerAddress {
    /**
     * City name
     */
    'city': string;
    /**
     * Country code in ISO 3166-1 alpha-2 format
     */
    'country': string;
    /**
     * Neighborhood name
     */
    'neighborhood': string;
    /**
     * Address number
     */
    'number': string;
    /**
     * State code in ISO 3166-2 format
     */
    'state': string;
    /**
     * Street name
     */
    'street': string;
    /**
     * ZIP code without formatting
     */
    'zipCode': string;
}
/**
 * Merchant data for order or withdrawal
 */
export interface MerchantInput {
    /**
     * Merchant CPF or CNPJ without formatting
     */
    'document': string;
    /**
     * Merchant email
     */
    'email': string;
    /**
     * Merchant name
     */
    'name': string;
}
export interface NuPay {
    'paymentMethod': string;
    'nuPay': NuPayNuPay;
}
/**
 * Specific data for NuPay payment
 */
export interface NuPayNuPay {
    /**
     * Payment cancellation URL
     */
    'cancelUrl': string;
    /**
     * Merchant name
     */
    'merchantName': string;
    /**
     * Return URL after payment completion
     */
    'returnUrl': string;
    /**
     * Store name
     */
    'storeName'?: string;
}
export interface PicPay {
    'paymentMethod': string;
}
export interface Pix {
    'paymentMethod': string;
    'expirationInSeconds'?: PixExpirationInSeconds;
}
/**
 * PIX expiration time in seconds
 */
export interface PixExpirationInSeconds {
}
export interface PostCardTokenization200Response {
    /**
     * ID of the customer associated with the created card
     */
    'customerId': string;
    /**
     * Token of the created card for future transactions
     */
    'token': string;
}
/**
 * Data for creating a customer card
 */
export interface PostCardTokenizationRequest {
    'card': CompleteCardData;
    /**
     * Indicates if the card should be saved for future use
     */
    'saveCard': boolean;
    'customer': PostCardTokenizationRequestCustomer;
}
export interface PostCardTokenizationRequestCustomer {
    'address'?: CustomerAddress;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber': string;
    'documentType': Customer2DocumentType;
    /**
     * Customer email
     */
    'email': string;
    /**
     * Customer full name
     */
    'name': string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
    /**
     * ID do cliente existente
     */
    'id': string;
}
export interface PostCardTokenizationRequestCustomerAnyOf {
    /**
     * ID do cliente existente
     */
    'id': string;
}
export interface PostOrders200Response {
    /**
     * Order ID in the system
     */
    'id': string;
    /**
     * External order ID (provided by your integration)
     */
    'externalId': string | null;
    /**
     * Provider used to process the order
     */
    'externalIntegrationKey': string;
    /**
     * Order ID in the payment provider
     */
    'externalIntegrationId': string | null;
    /**
     * Total order amount
     */
    'amount': number;
    /**
     * Cost fee applied to the order
     */
    'costFee': number;
    'pix'?: PostOrders200ResponsePix;
    'bankSlip'?: PostOrders200ResponseBankSlip;
    'nuPay'?: PostOrders200ResponseNuPay;
    'picPay'?: PostOrders200ResponsePicPay;
    'creditCard'?: PostOrders200ResponseCreditCard;
    'status': PostOrders200ResponseStatusEnum;
    'paymentMethod': PostOrders200ResponsePaymentMethodEnum;
    /**
     * Date and time when the order was paid (ISO 8601)
     */
    'payedAt': string | null;
    /**
     * Error code, if any
     */
    'errorCode': string | null;
    /**
     * Error message, if any
     */
    'errorMessage': string | null;
    'orderItems': Array<PostOrders200ResponseOrderItemsInner>;
    'session'?: PostOrders200ResponseSession | null;
}

export const PostOrders200ResponseStatusEnum = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback'
} as const;

export type PostOrders200ResponseStatusEnum = typeof PostOrders200ResponseStatusEnum[keyof typeof PostOrders200ResponseStatusEnum];
export const PostOrders200ResponsePaymentMethodEnum = {
    Pix: 'Pix',
    CreditCard: 'CreditCard',
    DebitCard: 'DebitCard',
    BankSlip: 'BankSlip',
    Crypto: 'Crypto',
    ApplePay: 'ApplePay',
    NuPay: 'NuPay',
    PicPay: 'PicPay',
    AmazonPay: 'AmazonPay',
    SepaDebit: 'SepaDebit',
    GooglePay: 'GooglePay'
} as const;

export type PostOrders200ResponsePaymentMethodEnum = typeof PostOrders200ResponsePaymentMethodEnum[keyof typeof PostOrders200ResponsePaymentMethodEnum];

export interface PostOrders200ResponseBankSlip {
    /**
     * Bank slip bar code
     */
    'barCode': string;
    /**
     * Bank slip digitable line
     */
    'digitableLine': string;
    /**
     * Bank slip PDF URL
     */
    'pdfUrl'?: string;
}
export interface PostOrders200ResponseCreditCard {
    /**
     * Transaction authorization code
     */
    'authorizationCode'?: string;
}
export interface PostOrders200ResponseNuPay {
    /**
     * NuPay payment URL
     */
    'paymentUrl': string;
}
export interface PostOrders200ResponseOrderItemsInner {
    /**
     * External item ID
     */
    'externalId': string | null;
    /**
     * Item ID in the order
     */
    'id': string;
    /**
     * Product/service name
     */
    'name': string;
    /**
     * Quantity
     */
    'qty': number;
    /**
     * Total item amount (quantity Ã— unit price)
     */
    'totalAmount': number;
    /**
     * Total net amount of the item
     */
    'totalNetAmount': number;
    /**
     * Unit price
     */
    'unityPrice': number;
}
export interface PostOrders200ResponsePicPay {
    /**
     * PicPay copy and paste code
     */
    'copyAndPasteCode': string;
    /**
     * PicPay QR Code image URL
     */
    'qrCodeUrl': string;
}
/**
 * PIX data
 */
export interface PostOrders200ResponsePix {
    /**
     * PIX copy and paste code
     */
    'copyAndPasteCode': string;
    /**
     * PIX QR Code image URL
     */
    'qrCodeUrl': string;
    /**
     * PIX E2E ID
     */
    'endToEndId': string | null;
}
export interface PostOrders200ResponseSession {
    /**
     * ID of the checkout session associated with the order
     */
    'sessionId': string;
}
export interface PostOrdersRequest {
    /**
     * Total amount to be charged on the order in floating point value
     */
    'chargeAmount': number;
    /**
     * Client IP address
     */
    'clientIp': string;
    'customer': Customer;
    /**
     * Discount amount
     */
    'discountAmount': number;
    /**
     * Order ID in your system
     */
    'externalId': string;
    'fingerprints'?: PostOrdersRequestFingerprints;
    /**
     * List of products or services in the order
     */
    'items'?: Array<PostOrdersRequestItemsInner>;
    'merchant'?: MerchantInput;
    'payment': PostOrdersRequestPayment;
    /**
     * Total split amount to be paid to the merchant (Used only for reporting purposes, does not generate actual split)
     */
    'splitAmountTotal'?: number;
    'session'?: PostOrdersRequestSession;
    /**
     * Shipping fee
     */
    'shippingFee': number;
    /**
     * Additional fees
     */
    'taxFee': number;
    /**
     * Additional metadata for the order as key-value pairs. Keys should not contain spaces or special characters
     */
    'metadata'?: object;
}
export interface PostOrdersRequestFingerprints {
    /**
     * ThreatMetrix fingerprint ID for fraud analysis
     */
    'threatMetrixFingerprintId'?: string;
}
export interface PostOrdersRequestItemsInner {
    /**
     * Product or service ID in your system
     */
    'id': string;
    /**
     * Defines if the item is a physical product or a service
     */
    'isPhysical': boolean;
    /**
     * Product or service name
     */
    'name': string;
    /**
     * Quantity of the product or service
     */
    'qty': number;
    /**
     * Unit price
     */
    'unitPrice': number;
}
/**
 * Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
 */
export interface PostOrdersRequestPayment {
    'paymentMethod': string;
    'expirationInSeconds'?: PixExpirationInSeconds;
    'card': CreditCardCard;
    'installments': CreditCardInstallments;
    /**
     * Text that will appear on the card statement (soft descriptor)
     */
    'softDescriptor'?: string;
    'expirationInDays'?: BankSlipExpirationInDays;
    'nuPay': NuPayNuPay;
}
/**
 * If externalSessionId or sessionId is provided and an existing session exists, it will be updated with the new data. Otherwise, a new session will be created.
 */
export interface PostOrdersRequestSession {
    /**
     * Time in minutes for checkout session expiration
     */
    'expiresInMinutes'?: number;
    /**
     * Checkout URL for redirection
     */
    'checkoutUrl'?: string;
    /**
     * ID generated by our service to identify the checkout session
     */
    'sessionId'?: string;
    /**
     * Checkout session ID generated by the client side. The ID must be unique for each cart session
     */
    'externalSessionId'?: string;
}
export interface PostWithdraws200Response {
    /**
     * Unique withdrawal identifier
     */
    'id': string;
    /**
     * Withdrawal ID in your system
     */
    'externalId': string | null;
    /**
     * Provider key used for the withdrawal
     */
    'externalIntegrationKey': string;
    /**
     * Withdrawal ID in the payment provider
     */
    'externalIntegrationId': string | null;
    /**
     * Cost fee applied to the withdrawal
     */
    'costFee': number;
    /**
     * Withdrawal status
     */
    'status': PostWithdraws200ResponseStatusEnum;
    /**
     * Error code, if any
     */
    'errorCode': string | null;
    /**
     * Descriptive error message, if any
     */
    'errorMessage': string | null;
    'payedAt': PostWithdraws200ResponsePayedAt | null;
    'payoutAccount': PostWithdraws200ResponsePayoutAccount;
}

export const PostWithdraws200ResponseStatusEnum = {
    Pending: 'Pending',
    Transferring: 'Transferring',
    Completed: 'Completed',
    Failed: 'Failed'
} as const;

export type PostWithdraws200ResponseStatusEnum = typeof PostWithdraws200ResponseStatusEnum[keyof typeof PostWithdraws200ResponseStatusEnum];

/**
 * Date and time when the withdrawal was paid (ISO 8601 format)
 */
export interface PostWithdraws200ResponsePayedAt {
}
export interface PostWithdraws200ResponsePayoutAccount {
    /**
     * Unique payment account identifier
     */
    'id': string;
    /**
     * Account holder document (CPF or CNPJ)
     */
    'ownerDocument': string;
    /**
     * Account holder name
     */
    'ownerName': string;
    /**
     * PIX key used for the withdrawal
     */
    'pixKey': string;
    /**
     * PIX key type
     */
    'pixType': PostWithdraws200ResponsePayoutAccountPixTypeEnum;
}

export const PostWithdraws200ResponsePayoutAccountPixTypeEnum = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj',
    Email: 'Email',
    Phone: 'Phone',
    Random: 'Random'
} as const;

export type PostWithdraws200ResponsePayoutAccountPixTypeEnum = typeof PostWithdraws200ResponsePayoutAccountPixTypeEnum[keyof typeof PostWithdraws200ResponsePayoutAccountPixTypeEnum];

export interface PostWithdrawsRequest {
    /**
     * Withdrawal amount in cents
     */
    'amount': number;
    /**
     * Withdrawal ID in your system
     */
    'externalId'?: string;
    'merchant'?: MerchantInput;
    'payoutAccount': PostWithdrawsRequestPayoutAccount;
}
export interface PostWithdrawsRequestPayoutAccount {
    /**
     * Account holder document (CPF or CNPJ)
     */
    'ownerDocument': string;
    /**
     * Account holder name
     */
    'ownerName': string;
    /**
     * PIX key for withdrawal
     */
    'pixKey': string;
    /**
     * PIX key type
     */
    'pixType': PostWithdrawsRequestPayoutAccountPixTypeEnum;
}

export const PostWithdrawsRequestPayoutAccountPixTypeEnum = {
    Cnpj: 'Cnpj',
    Cpf: 'Cpf',
    Email: 'Email',
    Phone: 'Phone',
    Random: 'Random'
} as const;

export type PostWithdrawsRequestPayoutAccountPixTypeEnum = typeof PostWithdrawsRequestPayoutAccountPixTypeEnum[keyof typeof PostWithdrawsRequestPayoutAccountPixTypeEnum];

export interface TokenizedCard {
    /**
     * First 6 digits of the credit card
     */
    'firstSixCardNumber'?: string;
    /**
     * Previously generated credit card token
     */
    'token': string;
}

/**
 * CardTokenizationApi - axios parameter creator
 */
export const CardTokenizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize card
         * @param {PostCardTokenizationRequest} postCardTokenizationRequest Data for creating a customer card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardTokenization: async (postCardTokenizationRequest: PostCardTokenizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCardTokenizationRequest' is not null or undefined
            assertParamExists('postCardTokenization', 'postCardTokenizationRequest', postCardTokenizationRequest)
            const localVarPath = `/card-tokenization/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCardTokenizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardTokenizationApi - functional programming interface
 */
export const CardTokenizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardTokenizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize card
         * @param {PostCardTokenizationRequest} postCardTokenizationRequest Data for creating a customer card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCardTokenization(postCardTokenizationRequest: PostCardTokenizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCardTokenization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCardTokenization(postCardTokenizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardTokenizationApi.postCardTokenization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardTokenizationApi - factory interface
 */
export const CardTokenizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardTokenizationApiFp(configuration)
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize card
         * @param {PostCardTokenizationRequest} postCardTokenizationRequest Data for creating a customer card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardTokenization(postCardTokenizationRequest: PostCardTokenizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostCardTokenization200Response> {
            return localVarFp.postCardTokenization(postCardTokenizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardTokenizationApi - object-oriented interface
 */
export class CardTokenizationApi extends BaseAPI {
    /**
     * Tokenize credit cards for future charges.
     * @summary Tokenize card
     * @param {PostCardTokenizationRequest} postCardTokenizationRequest Data for creating a customer card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCardTokenization(postCardTokenizationRequest: PostCardTokenizationRequest, options?: RawAxiosRequestConfig) {
        return CardTokenizationApiFp(this.configuration).postCardTokenization(postCardTokenizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomersApi - axios parameter creator
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomersById', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {GetCustomersPeriodEnum} period 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (page: number, pageSize: number, period: GetCustomersPeriodEnum, email?: string, name?: string, endDate?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getCustomers', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCustomers', 'pageSize', pageSize)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getCustomers', 'period', period)
            const localVarPath = `/customers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomersById', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Customer1} customer1 Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomersById: async (id: string, customer1: Customer1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchCustomersById', 'id', id)
            // verify required parameter 'customer1' is not null or undefined
            assertParamExists('patchCustomersById', 'customer1', customer1)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customer1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Customer} customer Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers: async (customer: Customer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('postCustomers', 'customer', customer)
            const localVarPath = `/customers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomersById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomersById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.deleteCustomersById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {GetCustomersPeriodEnum} period 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(page: number, pageSize: number, period: GetCustomersPeriodEnum, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(page, pageSize, period, email, name, endDate, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getCustomersById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {Customer1} customer1 Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCustomersById(id: string, customer1: Customer1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCustomersById(id, customer1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.patchCustomersById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Customer} customer Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomers(customer: Customer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomers(customer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.postCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomersApi - factory interface
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {GetCustomersPeriodEnum} period 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(page: number, pageSize: number, period: GetCustomersPeriodEnum, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomers(page, pageSize, period, email, name, endDate, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {Customer1} customer1 Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomersById(id: string, customer1: Customer1, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchCustomersById(id, customer1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Customer} customer Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(customer: Customer, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCustomers(customer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCustomersById(id: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomersById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {GetCustomersPeriodEnum} period 
     * @param {string} [email] 
     * @param {string} [name] 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomers(page: number, pageSize: number, period: GetCustomersPeriodEnum, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(page, pageSize, period, email, name, endDate, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomersById(id: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomersById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {Customer1} customer1 Schema for creating a new customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchCustomersById(id: string, customer1: Customer1, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).patchCustomersById(id, customer1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Customer} customer Schema for creating a new customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCustomers(customer: Customer, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).postCustomers(customer, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCustomersPeriodEnum = {
    Today: 'Today',
    Yesterday: 'Yesterday',
    Last7Days: 'Last7Days',
    Last30Days: 'Last30Days',
    ThisMonth: 'ThisMonth',
    LastMonth: 'LastMonth',
    ThisYear: 'ThisYear',
    Custom: 'Custom'
} as const;
export type GetCustomersPeriodEnum = typeof GetCustomersPeriodEnum[keyof typeof GetCustomersPeriodEnum];


/**
 * OrdersApi - axios parameter creator
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List orders
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getOrders', 'period', period)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getOrders', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getOrders', 'pageSize', pageSize)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrdersById', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create order
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders: async (postOrdersRequest: PostOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postOrdersRequest' is not null or undefined
            assertParamExists('postOrders', 'postOrdersRequest', postOrdersRequest)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersByIdRefund: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersByIdRefund', 'id', id)
            const localVarPath = `/orders/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List orders
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(period, page, pageSize, endDate, startDate, id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrdersById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create order
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrders(postOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.postOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersByIdRefund(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.postOrdersByIdRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List orders
         * @param {GetOrdersPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {GetOrdersStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOrders(period, page, pageSize, endDate, startDate, id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOrdersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create order
         * @param {PostOrdersRequest} postOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostOrders200Response> {
            return localVarFp.postOrders(postOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postOrdersByIdRefund(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 */
export class OrdersApi extends BaseAPI {
    /**
     * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
     * @summary List orders
     * @param {GetOrdersPeriodEnum} period 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {GetOrdersStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrders(period: GetOrdersPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: GetOrdersStatusEnum, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrders(period, page, pageSize, endDate, startDate, id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the complete data of an order by our ID
     * @summary Get order by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrdersById(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order for payment using the provided data
     * @summary Create order
     * @param {PostOrdersRequest} postOrdersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postOrders(postOrdersRequest: PostOrdersRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).postOrders(postOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a refund for the order specified by ID.
     * @summary Refund order
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postOrdersByIdRefund(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).postOrdersByIdRefund(id, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetOrdersPeriodEnum = {
    Today: 'Today',
    Yesterday: 'Yesterday',
    Last7Days: 'Last7Days',
    Last30Days: 'Last30Days',
    ThisMonth: 'ThisMonth',
    LastMonth: 'LastMonth',
    ThisYear: 'ThisYear',
    Custom: 'Custom'
} as const;
export type GetOrdersPeriodEnum = typeof GetOrdersPeriodEnum[keyof typeof GetOrdersPeriodEnum];
export const GetOrdersStatusEnum = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback'
} as const;
export type GetOrdersStatusEnum = typeof GetOrdersStatusEnum[keyof typeof GetOrdersStatusEnum];


/**
 * WithdrawalsAndTransfersApi - axios parameter creator
 */
export const WithdrawalsAndTransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List withdrawals
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdraws: async (period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getWithdraws', 'period', period)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getWithdraws', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getWithdraws', 'pageSize', pageSize)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get withdrawal by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawsById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWithdrawsById', 'id', id)
            const localVarPath = `/withdraws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create withdrawal
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraws: async (postWithdrawsRequest: PostWithdrawsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postWithdrawsRequest' is not null or undefined
            assertParamExists('postWithdraws', 'postWithdrawsRequest', postWithdrawsRequest)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postWithdrawsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalsAndTransfersApi - functional programming interface
 */
export const WithdrawalsAndTransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalsAndTransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List withdrawals
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdraws(period, page, pageSize, endDate, startDate, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalsAndTransfersApi.getWithdraws']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get withdrawal by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawsById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawsById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalsAndTransfersApi.getWithdrawsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create withdrawal
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWithdraws200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWithdraws(postWithdrawsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalsAndTransfersApi.postWithdraws']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WithdrawalsAndTransfersApi - factory interface
 */
export const WithdrawalsAndTransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalsAndTransfersApiFp(configuration)
    return {
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List withdrawals
         * @param {GetWithdrawsPeriodEnum} period 
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getWithdraws(period, page, pageSize, endDate, startDate, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get withdrawal by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawsById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getWithdrawsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create withdrawal
         * @param {PostWithdrawsRequest} postWithdrawsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostWithdraws200Response> {
            return localVarFp.postWithdraws(postWithdrawsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalsAndTransfersApi - object-oriented interface
 */
export class WithdrawalsAndTransfersApi extends BaseAPI {
    /**
     * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
     * @summary List withdrawals
     * @param {GetWithdrawsPeriodEnum} period 
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdraws(period: GetWithdrawsPeriodEnum, page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig) {
        return WithdrawalsAndTransfersApiFp(this.configuration).getWithdraws(period, page, pageSize, endDate, startDate, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific withdrawal or transfer using its ID
     * @summary Get withdrawal by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdrawsById(id: string, options?: RawAxiosRequestConfig) {
        return WithdrawalsAndTransfersApiFp(this.configuration).getWithdrawsById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new withdrawal or transfer to the provided payment account
     * @summary Create withdrawal
     * @param {PostWithdrawsRequest} postWithdrawsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWithdraws(postWithdrawsRequest: PostWithdrawsRequest, options?: RawAxiosRequestConfig) {
        return WithdrawalsAndTransfersApiFp(this.configuration).postWithdraws(postWithdrawsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetWithdrawsPeriodEnum = {
    Today: 'Today',
    Yesterday: 'Yesterday',
    Last7Days: 'Last7Days',
    Last30Days: 'Last30Days',
    ThisMonth: 'ThisMonth',
    LastMonth: 'LastMonth',
    ThisYear: 'ThisYear',
    Custom: 'Custom'
} as const;
export type GetWithdrawsPeriodEnum = typeof GetWithdrawsPeriodEnum[keyof typeof GetWithdrawsPeriodEnum];


