/* tslint:disable */
/* eslint-disable */
/**
 * PayConductor API
 * PayConductor API Documentation.  This documentation covers all available features in the PayConductor RESTful API, including authentication, resource management, and usage examples.  <br />  <br />  ----  <br />   # Authentication  PayConductor API uses HTTP Basic authentication to validate requests. You need to provide your credentials (Client ID and Client Secret) in the `client:secret` format encoded in Base64.  <br />  ## Getting Credentials  1. Access the PayConductor admin panel 2. Navigate to **Settings > API Keys** 3. Generate a new credentials pair (Client ID and Client Secret) 4. Store the Client Secret in a secure location - it will not be displayed again  <br />  ## Authentication Format  Credentials must be sent in the `Authorization` header using the Basic scheme:  ``` Authorization: Basic base64(client_id:client_secret) ```  <br />  ## Node.js Example  ```javascript const clientId = \'your_client_id\'; const clientSecret = \'your_client_secret\';  // Encode credentials in Base64 const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString(\'base64\');  const response = await fetch(\'https://api.payconductor.com/api/v1/orders\', {   method: \'GET\',   headers: {     \'Authorization\': `Basic ${credentials}`,     \'Content-Type\': \'application/json\'   } });  const data = await response.json(); console.log(data); ```  <br />  ## Authentication Errors  | Code | Description | |------|-------------| | `401` | Invalid or missing credentials | | `403` | Valid credentials but no permission for the resource | | `429` | Too many requests (rate limit exceeded) |  ### Error Response Example  ```json {   \"error\": {     \"code\": \"UNAUTHORIZED\",     \"message\": \"Invalid credentials\",     \"details\": \"The provided client ID or secret is incorrect\"   } } ```
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Schema for creating a new address
 */
export interface AddressCreateRequest {
    /**
     * City name
     */
    'city': string;
    /**
     * Country code in ISO 3166-1 alpha-2 format
     */
    'country': string;
    /**
     * Neighborhood name
     */
    'neighborhood': string;
    /**
     * Address number
     */
    'number': string;
    /**
     * State code in ISO 3166-2 format
     */
    'state': string;
    /**
     * Street name
     */
    'street': string;
    /**
     * ZIP code without formatting
     */
    'zipCode': string;
}

export const AvailablePaymentMethods = {
    Pix: 'Pix',
    CreditCard: 'CreditCard',
    DebitCard: 'DebitCard',
    BankSlip: 'BankSlip',
    Crypto: 'Crypto',
    ApplePay: 'ApplePay',
    NuPay: 'NuPay',
    PicPay: 'PicPay',
    AmazonPay: 'AmazonPay',
    SepaDebit: 'SepaDebit',
    GooglePay: 'GooglePay',
    Draft: 'Draft'
} as const;

export type AvailablePaymentMethods = typeof AvailablePaymentMethods[keyof typeof AvailablePaymentMethods];


/**
 * Complete card data for payment processing
 */
export interface CardCreateRequest {
    /**
     * Card security code (CVV)
     */
    'cvv': string;
    'expiration': CardExpirationData;
    /**
     * Card holder name
     */
    'holderName': string;
    /**
     * Credit card number
     */
    'number': string;
}
/**
 * Card expiration date
 */
export interface CardExpirationData {
    /**
     * Card expiration month
     */
    'month': number;
    /**
     * Card expiration year
     */
    'year': number;
}
/**
 * Data for creating a customer card with customer information
 */
export interface CardTokenizationCreateRequest {
    'card': CardCreateRequest;
    /**
     * Indicates if the card should be saved for future use
     */
    'saveCard': boolean;
    'customer': CardTokenizationCreateRequestCustomer;
}
/**
 * @type CardTokenizationCreateRequestCustomer
 */
export type CardTokenizationCreateRequestCustomer = CardTokenizationCustomerByIdData | CustomerCreateRequest;

/**
 * Response containing customer ID and card token
 */
export interface CardTokenizationCreateResponse {
    /**
     * ID of the customer associated with the created card
     */
    'customerId': string;
    /**
     * Token of the created card for future transactions
     */
    'token': string;
}
/**
 * Reference to an existing customer by ID
 */
export interface CardTokenizationCustomerByIdData {
    /**
     * ID of an existing customer
     */
    'id': string;
}
/**
 * Customer address information
 */
export interface CustomerAddressResponse {
    /**
     * Unique address identifier
     */
    'id': string;
    /**
     * Street name
     */
    'street': string;
    /**
     * Address number
     */
    'number': string;
    /**
     * Neighborhood name
     */
    'neighborhood': string;
    /**
     * City name
     */
    'city': string;
    /**
     * State code in ISO 3166-2 format
     */
    'state': string;
    /**
     * ZIP code without formatting
     */
    'zipCode': string;
    /**
     * Country code in ISO 3166-1 alpha-2 format
     */
    'country': string;
}
/**
 * Schema for creating a new customer
 */
export interface CustomerCreateRequest {
    'address'?: AddressCreateRequest;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber': string;
    'documentType': DocumentType;
    /**
     * Customer email
     */
    'email': string;
    /**
     * Customer full name
     */
    'name': string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
}


/**
 * Pagination information for customer list
 */
export interface CustomerListPagination {
    /**
     * Current page number
     */
    'currentPage': number;
    /**
     * Number of items per page
     */
    'pageSize': number;
    /**
     * Total number of customers
     */
    'totalItems': number;
    /**
     * Total number of pages
     */
    'totalPages': number;
}
/**
 * Paginated list of customers
 */
export interface CustomerListResponse {
    /**
     * List of customers
     */
    'data': Array<CustomerReadResponse>;
    'pagination': CustomerListPagination;
}
/**
 * Customer response with complete information
 */
export interface CustomerReadResponse {
    /**
     * Unique customer identifier
     */
    'id': string;
    /**
     * Customer full name
     */
    'name': string;
    /**
     * Customer email
     */
    'email': string;
    'documentType': DocumentType;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber': string | null;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber': string | null;
    'address': CustomerAddressResponse | null;
    /**
     * Date and time when the customer was created (ISO 8601 format)
     */
    'createdAt': string;
    /**
     * Date and time when the customer was last updated (ISO 8601 format)
     */
    'updatedAt': string;
}


/**
 * Schema for updating customer information
 */
export interface CustomerUpdateRequest {
    'address'?: AddressCreateRequest;
    /**
     * Customer CPF or CNPJ without formatting
     */
    'documentNumber'?: string;
    'documentType'?: DocumentType;
    /**
     * Customer email
     */
    'email'?: string;
    /**
     * Customer full name
     */
    'name'?: string;
    /**
     * Customer phone number in +55 DD 9XXXXXXXX format
     */
    'phoneNumber'?: string;
}



export const DocumentType = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];



export const Event = {
    OrderCreated: 'OrderCreated',
    OrderPending: 'OrderPending',
    OrderCompleted: 'OrderCompleted',
    OrderFailed: 'OrderFailed',
    OrderRefunded: 'OrderRefunded',
    OrderChargeback: 'OrderChargeback',
    WithdrawCreated: 'WithdrawCreated',
    WithdrawCompleted: 'WithdrawCompleted',
    WithdrawFailed: 'WithdrawFailed',
    WithdrawTransferring: 'WithdrawTransferring'
} as const;

export type Event = typeof Event[keyof typeof Event];


/**
 * Merchant data for order or withdrawal
 */
export interface MerchantInput {
    /**
     * Merchant CPF or CNPJ without formatting
     */
    'document': string;
    /**
     * Merchant email
     */
    'email': string;
    /**
     * Merchant name
     */
    'name': string;
}
/**
 * Bank slip payment data
 */
export interface OrderBankSlipInfo {
    /**
     * Bank slip bar code
     */
    'barCode': string;
    /**
     * Bank slip digitable line
     */
    'digitableLine': string;
    /**
     * Bank slip PDF URL
     */
    'pdfUrl'?: string;
}
export interface OrderBankSlipPaymentRequest {
    'paymentMethod': PaymentMethod;
    /**
     * Days until bank slip expires
     */
    'expirationInDays'?: number;
}


/**
 * Response after confirming a draft order
 */
export interface OrderConfirmResponse {
    /**
     * Order ID in the system
     */
    'id': string;
    /**
     * External order ID (provided by your integration)
     */
    'externalId': string | null;
    /**
     * Total order amount
     */
    'amount': number;
    /**
     * Cost fee applied to the order
     */
    'costFee': number;
    'pix'?: OrderPIXInfo;
    'bankSlip'?: OrderBankSlipInfo;
    'nuPay'?: OrderNuPayInfo;
    'picPay'?: OrderPicPayInfo;
    'status': Status;
    'paymentMethod': PaymentMethod;
    /**
     * Date and time when the order was paid (ISO 8601)
     */
    'payedAt': string | null;
    /**
     * Error code, if any
     */
    'errorCode': string | null;
    /**
     * Error message, if any
     */
    'errorMessage': string | null;
}


/**
 * Order data for payment processing
 */
export interface OrderCreateRequest {
    /**
     * Total amount to be charged on the order in floating point value
     */
    'chargeAmount': number;
    /**
     * Client IP address
     */
    'clientIp': string;
    'customer': CustomerCreateRequest;
    /**
     * Discount amount
     */
    'discountAmount': number;
    /**
     * Order ID in your system
     */
    'externalId': string;
    'fingerprints'?: OrderFraudFingerprints;
    /**
     * List of products or services in the order
     */
    'items'?: Array<OrderItemData>;
    'merchant'?: MerchantInput;
    'payment': OrderPaymentRequest;
    /**
     * Total split amount to be paid to the merchant (Used only for reporting purposes, does not generate actual split)
     */
    'splitAmountTotal'?: number;
    'session'?: OrderCreateRequestSession;
    /**
     * Shipping fee
     */
    'shippingFee': number;
    /**
     * Additional fees
     */
    'taxFee': number;
    /**
     * Additional metadata for the order as key-value pairs. Keys should not contain spaces or special characters
     */
    'metadata'?: object;
}
/**
 * If externalSessionId or sessionId is provided and an existing session exists, it will be updated with the new data. Otherwise, a new session will be created.
 */
export interface OrderCreateRequestSession {
    /**
     * Time in minutes for checkout session expiration
     */
    'expiresInMinutes'?: number;
    /**
     * Checkout URL for redirection
     */
    'checkoutUrl'?: string;
    /**
     * ID generated by our service to identify the checkout session
     */
    'sessionId'?: string;
    /**
     * Checkout session ID generated by the client side. The ID must be unique for each cart session
     */
    'externalSessionId'?: string;
}
/**
 * Response after creating an order
 */
export interface OrderCreateResponse {
    /**
     * Order ID in the system
     */
    'id': string;
    /**
     * External order ID (provided by your integration)
     */
    'externalId': string | null;
    /**
     * Provider used to process the order
     */
    'externalIntegrationKey': string;
    /**
     * Order ID in the payment provider
     */
    'externalIntegrationId': string | null;
    /**
     * Total order amount
     */
    'amount': number;
    /**
     * Cost fee applied to the order
     */
    'costFee': number;
    'pix'?: OrderPIXInfo;
    'bankSlip'?: OrderBankSlipInfo;
    'nuPay'?: OrderNuPayInfo;
    'picPay'?: OrderPicPayInfo;
    'creditCard'?: OrderCreditCardInfo;
    'status': Status;
    'paymentMethod': PaymentMethod;
    /**
     * Date and time when the order was paid (ISO 8601)
     */
    'payedAt': string | null;
    /**
     * Error code, if any
     */
    'errorCode': string | null;
    /**
     * Error message, if any
     */
    'errorMessage': string | null;
    'orderItems': Array<OrderCreateResponseOrderItemsInner>;
    'session'?: OrderCreateResponseSession | null;
}


export interface OrderCreateResponseOrderItemsInner {
    /**
     * External item ID
     */
    'externalId': string | null;
    /**
     * Item ID in the order
     */
    'id': string;
    /**
     * Product/service name
     */
    'name': string;
    /**
     * Quantity
     */
    'qty': number;
    /**
     * Total item amount (quantity Ã— unit price)
     */
    'totalAmount': number;
    /**
     * Total net amount of the item
     */
    'totalNetAmount': number;
    /**
     * Unit price
     */
    'unityPrice': number;
}
export interface OrderCreateResponseSession {
    /**
     * ID of the checkout session associated with the order
     */
    'sessionId': string;
}
/**
 * Credit card payment data
 */
export interface OrderCreditCardInfo {
    /**
     * Transaction authorization code
     */
    'authorizationCode'?: string;
}
export interface OrderCreditCardPaymentRequest {
    'paymentMethod': PaymentMethod;
    'card': OrderCreditCardPaymentRequestCard;
    /**
     * Number of installments
     */
    'installments': number;
    /**
     * Text that will appear on the card statement (soft descriptor)
     */
    'softDescriptor'?: string;
}


/**
 * @type OrderCreditCardPaymentRequestCard
 */
export type OrderCreditCardPaymentRequestCard = CardCreateRequest | OrderTokenizedCardData;

/**
 * Used to create an order without generating a real payment. Use to create orders that will be paid later
 */
export interface OrderDraftPaymentRequest {
    'paymentMethod': PaymentMethod;
    /**
     * Order expiration time in seconds
     */
    'expirationInSeconds'?: number;
    /**
     * Available payment methods for this order
     */
    'availablePaymentMethods'?: Array<AvailablePaymentMethods>;
}


/**
 * Fraud analysis fingerprint data
 */
export interface OrderFraudFingerprints {
    /**
     * ThreatMetrix fingerprint ID for fraud analysis
     */
    'threatMetrixFingerprintId'?: string;
}
/**
 * Product or service item in the order
 */
export interface OrderItemData {
    /**
     * Product or service ID in your system
     */
    'id': string;
    /**
     * Defines if the item is a physical product or a service
     */
    'isPhysical': boolean;
    /**
     * Product or service name
     */
    'name': string;
    /**
     * Quantity of the product or service
     */
    'qty': number;
    /**
     * Unit price
     */
    'unitPrice': number;
}
/**
 * NuPay payment data
 */
export interface OrderNuPayInfo {
    /**
     * NuPay payment URL
     */
    'paymentUrl': string;
}
export interface OrderNuPayPaymentRequest {
    'paymentMethod': PaymentMethod;
    'nuPay': OrderNuPayPaymentRequestNuPay;
}


/**
 * Specific data for NuPay payment
 */
export interface OrderNuPayPaymentRequestNuPay {
    /**
     * Payment cancellation URL
     */
    'cancelUrl': string;
    /**
     * Merchant name
     */
    'merchantName': string;
    /**
     * Return URL after payment completion
     */
    'returnUrl': string;
    /**
     * Store name
     */
    'storeName'?: string;
}
/**
 * PIX payment data and QR code information
 */
export interface OrderPIXInfo {
    /**
     * PIX copy and paste code
     */
    'copyAndPasteCode': string;
    /**
     * PIX QR Code image URL
     */
    'qrCodeUrl': string;
    /**
     * PIX E2E ID
     */
    'endToEndId': string | null;
}
export interface OrderPIXPaymentRequest {
    'paymentMethod': PaymentMethod;
    /**
     * PIX expiration time in seconds
     */
    'expirationInSeconds'?: number;
}


/**
 * @type OrderPaymentRequest
 * Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
 */
export type OrderPaymentRequest = { paymentMethod: 'OrderBankSlipPaymentRequest' } & OrderBankSlipPaymentRequest | { paymentMethod: 'OrderCreditCardPaymentRequest' } & OrderCreditCardPaymentRequest | { paymentMethod: 'OrderDraftPaymentRequest' } & OrderDraftPaymentRequest | { paymentMethod: 'OrderNuPayPaymentRequest' } & OrderNuPayPaymentRequest | { paymentMethod: 'OrderPIXPaymentRequest' } & OrderPIXPaymentRequest | { paymentMethod: 'OrderPicPayPaymentRequest' } & OrderPicPayPaymentRequest;

/**
 * PicPay payment data
 */
export interface OrderPicPayInfo {
    /**
     * PicPay copy and paste code
     */
    'copyAndPasteCode': string;
    /**
     * PicPay QR Code image URL
     */
    'qrCodeUrl': string;
}
export interface OrderPicPayPaymentRequest {
    'paymentMethod': PaymentMethod;
}


export interface OrderTokenizedCardData {
    /**
     * First 6 digits of the credit card
     */
    'firstSixCardNumber'?: string;
    /**
     * Previously generated credit card token
     */
    'token': string;
}

export const PaymentMethod = {
    Pix: 'Pix',
    CreditCard: 'CreditCard',
    DebitCard: 'DebitCard',
    BankSlip: 'BankSlip',
    Crypto: 'Crypto',
    ApplePay: 'ApplePay',
    NuPay: 'NuPay',
    PicPay: 'PicPay',
    AmazonPay: 'AmazonPay',
    SepaDebit: 'SepaDebit',
    GooglePay: 'GooglePay',
    Draft: 'Draft'
} as const;

export type PaymentMethod = typeof PaymentMethod[keyof typeof PaymentMethod];



export const PixType = {
    Cpf: 'Cpf',
    Cnpj: 'Cnpj',
    Email: 'Email',
    Phone: 'Phone',
    Random: 'Random'
} as const;

export type PixType = typeof PixType[keyof typeof PixType];



export const Status = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback',
    Transferring: 'Transferring'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * Withdrawal or transfer request data
 */
export interface WithdrawCreateRequest {
    /**
     * Withdrawal amount in cents
     */
    'amount': number;
    /**
     * Withdrawal ID in your system
     */
    'externalId'?: string;
    'merchant'?: MerchantInput;
    'payoutAccount': WithdrawPayoutAccountData;
}
/**
 * Response after creating a withdrawal or transfer
 */
export interface WithdrawCreateResponse {
    /**
     * Unique withdrawal identifier
     */
    'id': string;
    /**
     * Withdrawal ID in your system
     */
    'externalId': string | null;
    /**
     * Provider key used for the withdrawal
     */
    'externalIntegrationKey': string;
    /**
     * Withdrawal ID in the payment provider
     */
    'externalIntegrationId': string | null;
    /**
     * Cost fee applied to the withdrawal
     */
    'costFee': number;
    'status': Status;
    /**
     * Error code, if any
     */
    'errorCode': string | null;
    /**
     * Descriptive error message, if any
     */
    'errorMessage': string | null;
    'payedAt': WithdrawCreateResponsePayedAt | null;
    'payoutAccount': WithdrawCreateResponsePayoutAccount;
}


/**
 * Date and time when the withdrawal was paid (ISO 8601 format)
 */
export interface WithdrawCreateResponsePayedAt {
}
export interface WithdrawCreateResponsePayoutAccount {
    /**
     * Unique payment account identifier
     */
    'id': string;
    /**
     * Account holder document (CPF or CNPJ)
     */
    'ownerDocument': string;
    /**
     * Account holder name
     */
    'ownerName': string;
    /**
     * PIX key used for the withdrawal
     */
    'pixKey': string;
    'pixType': PixType;
}


/**
 * Bank account information for withdrawal
 */
export interface WithdrawPayoutAccountData {
    /**
     * Account holder document (CPF or CNPJ)
     */
    'ownerDocument': string;
    /**
     * Account holder name
     */
    'ownerName': string;
    /**
     * PIX key for withdrawal
     */
    'pixKey': string;
    'pixType': PixType;
}



/**
 * CardTokenizationApi - axios parameter creator
 */
export const CardTokenizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize Card
         * @param {CardTokenizationCreateRequest} cardTokenizationCreateRequest Data for creating a customer card with customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardTokenize: async (cardTokenizationCreateRequest: CardTokenizationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardTokenizationCreateRequest' is not null or undefined
            assertParamExists('cardTokenize', 'cardTokenizationCreateRequest', cardTokenizationCreateRequest)
            const localVarPath = `/card-tokenization/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardTokenizationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardTokenizationApi - functional programming interface
 */
export const CardTokenizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardTokenizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize Card
         * @param {CardTokenizationCreateRequest} cardTokenizationCreateRequest Data for creating a customer card with customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardTokenize(cardTokenizationCreateRequest: CardTokenizationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardTokenizationCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardTokenize(cardTokenizationCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardTokenizationApi.cardTokenize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardTokenizationApi - factory interface
 */
export const CardTokenizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardTokenizationApiFp(configuration)
    return {
        /**
         * Tokenize credit cards for future charges.
         * @summary Tokenize Card
         * @param {CardTokenizationCreateRequest} cardTokenizationCreateRequest Data for creating a customer card with customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardTokenize(cardTokenizationCreateRequest: CardTokenizationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardTokenizationCreateResponse> {
            return localVarFp.cardTokenize(cardTokenizationCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardTokenizationApi - object-oriented interface
 */
export class CardTokenizationApi extends BaseAPI {
    /**
     * Tokenize credit cards for future charges.
     * @summary Tokenize Card
     * @param {CardTokenizationCreateRequest} cardTokenizationCreateRequest Data for creating a customer card with customer information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cardTokenize(cardTokenizationCreateRequest: CardTokenizationCreateRequest, options?: RawAxiosRequestConfig) {
        return CardTokenizationApiFp(this.configuration).cardTokenize(cardTokenizationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerApi - axios parameter creator
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new customer by providing the required data in the request body.
         * @summary Create New Customer
         * @param {CustomerCreateRequest} customerCreateRequest Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate: async (customerCreateRequest: CustomerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerCreateRequest' is not null or undefined
            assertParamExists('customerCreate', 'customerCreateRequest', customerCreateRequest)
            const localVarPath = `/customers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all customers associated with the organization, with support for filters and pagination.
         * @summary Get All Customers
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListCustom: async (page: number, pageSize: number, email?: string, name?: string, endDate?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('customerListCustom', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('customerListCustom', 'pageSize', pageSize)
            const localVarPath = `/customers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the complete details of a specific customer using their unique ID.
         * @summary Get Customer By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRead: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customerRead', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the information of an existing customer by providing the new data in the request body.
         * @summary Update Customer Data
         * @param {string} id 
         * @param {CustomerUpdateRequest} customerUpdateRequest Schema for updating customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate: async (id: string, customerUpdateRequest: CustomerUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customerUpdate', 'id', id)
            // verify required parameter 'customerUpdateRequest' is not null or undefined
            assertParamExists('customerUpdate', 'customerUpdateRequest', customerUpdateRequest)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new customer by providing the required data in the request body.
         * @summary Create New Customer
         * @param {CustomerCreateRequest} customerCreateRequest Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreate(customerCreateRequest: CustomerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(customerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.customerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all customers associated with the organization, with support for filters and pagination.
         * @summary Get All Customers
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerListCustom(page: number, pageSize: number, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerListCustom(page, pageSize, email, name, endDate, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.customerListCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the complete details of a specific customer using their unique ID.
         * @summary Get Customer By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerRead(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.customerRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the information of an existing customer by providing the new data in the request body.
         * @summary Update Customer Data
         * @param {string} id 
         * @param {CustomerUpdateRequest} customerUpdateRequest Schema for updating customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerUpdate(id: string, customerUpdateRequest: CustomerUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(id, customerUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.customerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerApi - factory interface
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Create a new customer by providing the required data in the request body.
         * @summary Create New Customer
         * @param {CustomerCreateRequest} customerCreateRequest Schema for creating a new customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate(customerCreateRequest: CustomerCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerReadResponse> {
            return localVarFp.customerCreate(customerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all customers associated with the organization, with support for filters and pagination.
         * @summary Get All Customers
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListCustom(page: number, pageSize: number, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerListResponse> {
            return localVarFp.customerListCustom(page, pageSize, email, name, endDate, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the complete details of a specific customer using their unique ID.
         * @summary Get Customer By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRead(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerReadResponse> {
            return localVarFp.customerRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the information of an existing customer by providing the new data in the request body.
         * @summary Update Customer Data
         * @param {string} id 
         * @param {CustomerUpdateRequest} customerUpdateRequest Schema for updating customer information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate(id: string, customerUpdateRequest: CustomerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerReadResponse> {
            return localVarFp.customerUpdate(id, customerUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 */
export class CustomerApi extends BaseAPI {
    /**
     * Create a new customer by providing the required data in the request body.
     * @summary Create New Customer
     * @param {CustomerCreateRequest} customerCreateRequest Schema for creating a new customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerCreate(customerCreateRequest: CustomerCreateRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).customerCreate(customerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all customers associated with the organization, with support for filters and pagination.
     * @summary Get All Customers
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [email] 
     * @param {string} [name] 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerListCustom(page: number, pageSize: number, email?: string, name?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).customerListCustom(page, pageSize, email, name, endDate, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the complete details of a specific customer using their unique ID.
     * @summary Get Customer By ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerRead(id: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).customerRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the information of an existing customer by providing the new data in the request body.
     * @summary Update Customer Data
     * @param {string} id 
     * @param {CustomerUpdateRequest} customerUpdateRequest Schema for updating customer information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerUpdate(id: string, customerUpdateRequest: CustomerUpdateRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).customerUpdate(id, customerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Confirms a Draft order, setting the payment method and processing the charges associated with the order.
         * @summary Confirm Order
         * @param {string} id 
         * @param {OrderPaymentRequest} orderPaymentRequest Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderConfirm: async (id: string, orderPaymentRequest: OrderPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderConfirm', 'id', id)
            // verify required parameter 'orderPaymentRequest' is not null or undefined
            assertParamExists('orderConfirm', 'orderPaymentRequest', orderPaymentRequest)
            const localVarPath = `/orders/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create Order
         * @param {OrderCreateRequest} orderCreateRequest Order data for payment processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreate: async (orderCreateRequest: OrderCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreateRequest' is not null or undefined
            assertParamExists('orderCreate', 'orderCreateRequest', orderCreateRequest)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List Orders
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {OrderListStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderList: async (page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: OrderListStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('orderList', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('orderList', 'pageSize', pageSize)
            const localVarPath = `/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get Order By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRead: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderRead', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund Order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRefund: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderRefund', 'id', id)
            const localVarPath = `/orders/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Confirms a Draft order, setting the payment method and processing the charges associated with the order.
         * @summary Confirm Order
         * @param {string} id 
         * @param {OrderPaymentRequest} orderPaymentRequest Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderConfirm(id: string, orderPaymentRequest: OrderPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderConfirmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderConfirm(id, orderPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create Order
         * @param {OrderCreateRequest} orderCreateRequest Order data for payment processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCreate(orderCreateRequest: OrderCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCreate(orderCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List Orders
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {OrderListStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: OrderListStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderList(page, pageSize, endDate, startDate, id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get Order By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderRead(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund Order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderRefund(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderRefund(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Confirms a Draft order, setting the payment method and processing the charges associated with the order.
         * @summary Confirm Order
         * @param {string} id 
         * @param {OrderPaymentRequest} orderPaymentRequest Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderConfirm(id: string, orderPaymentRequest: OrderPaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderConfirmResponse> {
            return localVarFp.orderConfirm(id, orderPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order for payment using the provided data
         * @summary Create Order
         * @param {OrderCreateRequest} orderCreateRequest Order data for payment processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreate(orderCreateRequest: OrderCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderCreateResponse> {
            return localVarFp.orderCreate(orderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
         * @summary List Orders
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {OrderListStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: OrderListStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderList(page, pageSize, endDate, startDate, id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the complete data of an order by our ID
         * @summary Get Order By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRead(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a refund for the order specified by ID.
         * @summary Refund Order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRefund(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderRefund(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /**
     * Confirms a Draft order, setting the payment method and processing the charges associated with the order.
     * @summary Confirm Order
     * @param {string} id 
     * @param {OrderPaymentRequest} orderPaymentRequest Payment data for the order (Pix, Credit Card, Bank Slip, NuPay, etc...)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderConfirm(id: string, orderPaymentRequest: OrderPaymentRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderConfirm(id, orderPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order for payment using the provided data
     * @summary Create Order
     * @param {OrderCreateRequest} orderCreateRequest Order data for payment processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderCreate(orderCreateRequest: OrderCreateRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderCreate(orderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of orders. Use date filter and pagination parameters to refine results as needed.
     * @summary List Orders
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {OrderListStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, status?: OrderListStatusEnum, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderList(page, pageSize, endDate, startDate, id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the complete data of an order by our ID
     * @summary Get Order By ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderRead(id: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a refund for the order specified by ID.
     * @summary Refund Order
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderRefund(id: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderRefund(id, options).then((request) => request(this.axios, this.basePath));
    }
}

export const OrderListStatusEnum = {
    Generating: 'Generating',
    Pending: 'Pending',
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Refunding: 'Refunding',
    Refunded: 'Refunded',
    InDispute: 'InDispute',
    Chargeback: 'Chargeback'
} as const;
export type OrderListStatusEnum = typeof OrderListStatusEnum[keyof typeof OrderListStatusEnum];


/**
 * WithdrawApi - axios parameter creator
 */
export const WithdrawApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create Withdrawal
         * @param {WithdrawCreateRequest} withdrawCreateRequest Withdrawal or transfer request data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawCreate: async (withdrawCreateRequest: WithdrawCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawCreateRequest' is not null or undefined
            assertParamExists('withdrawCreate', 'withdrawCreateRequest', withdrawCreateRequest)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List Withdrawals
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawList: async (page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('withdrawList', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('withdrawList', 'pageSize', pageSize)
            const localVarPath = `/withdraws/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get Withdrawal By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRead: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('withdrawRead', 'id', id)
            const localVarPath = `/withdraws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawApi - functional programming interface
 */
export const WithdrawApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create Withdrawal
         * @param {WithdrawCreateRequest} withdrawCreateRequest Withdrawal or transfer request data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawCreate(withdrawCreateRequest: WithdrawCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawCreate(withdrawCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawApi.withdrawCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List Withdrawals
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawList(page, pageSize, endDate, startDate, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawApi.withdrawList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get Withdrawal By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRead(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawApi.withdrawRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WithdrawApi - factory interface
 */
export const WithdrawApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawApiFp(configuration)
    return {
        /**
         * Create a new withdrawal or transfer to the provided payment account
         * @summary Create Withdrawal
         * @param {WithdrawCreateRequest} withdrawCreateRequest Withdrawal or transfer request data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawCreate(withdrawCreateRequest: WithdrawCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawCreateResponse> {
            return localVarFp.withdrawCreate(withdrawCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
         * @summary List Withdrawals
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdrawList(page, pageSize, endDate, startDate, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific withdrawal or transfer using its ID
         * @summary Get Withdrawal By ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRead(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdrawRead(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawApi - object-oriented interface
 */
export class WithdrawApi extends BaseAPI {
    /**
     * Create a new withdrawal or transfer to the provided payment account
     * @summary Create Withdrawal
     * @param {WithdrawCreateRequest} withdrawCreateRequest Withdrawal or transfer request data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdrawCreate(withdrawCreateRequest: WithdrawCreateRequest, options?: RawAxiosRequestConfig) {
        return WithdrawApiFp(this.configuration).withdrawCreate(withdrawCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of withdrawals and transfers. Filter by creation date or search by ID (withdrawal ID, external ID, acquirer ID, or End2EndID)
     * @summary List Withdrawals
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdrawList(page: number, pageSize: number, endDate?: string, startDate?: string, id?: string, options?: RawAxiosRequestConfig) {
        return WithdrawApiFp(this.configuration).withdrawList(page, pageSize, endDate, startDate, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific withdrawal or transfer using its ID
     * @summary Get Withdrawal By ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdrawRead(id: string, options?: RawAxiosRequestConfig) {
        return WithdrawApiFp(this.configuration).withdrawRead(id, options).then((request) => request(this.axios, this.basePath));
    }
}



